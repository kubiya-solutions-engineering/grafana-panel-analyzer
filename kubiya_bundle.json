{
  "tools": [
    {
      "name": "analyze_grafana_panel",
      "source": null,
      "alias": null,
      "description": "Generate render URLs for relevant Grafana dashboard panels, download images, analyze them using OpenAI's vision model, and send results to the current Slack thread",
      "type": "docker",
      "content": "\npip install slack_sdk > /dev/null 2>&1\npip install requests > /dev/null 2>&1\npip install litellm==1.49.5 > /dev/null 2>&1\npip install pillow==11.0.0 > /dev/null 2>&1\n\npython /tmp/grafana.py     --alert_payload \"$alert_payload\"\n",
      "content_url": null,
      "args": [
        {
          "name": "alert_payload",
          "type": null,
          "description": "JSON string containing the alert payload",
          "required": true,
          "default": null,
          "options": null,
          "options_from": null
        }
      ],
      "env": [
        "SLACK_THREAD_TS",
        "SLACK_CHANNEL_ID",
        "VISION_LLM_BASE_URL"
      ],
      "secrets": [
        "SLACK_API_TOKEN",
        "GRAFANA_API_KEY",
        "VISION_LLM_KEY"
      ],
      "dependencies": null,
      "dependencies_url": null,
      "openapi": null,
      "with_files": [
        {
          "source": null,
          "destination": "/tmp/grafana.py",
          "content": "import os\nimport requests\nimport argparse\nimport tempfile\nfrom urllib.parse import urlparse, parse_qs\nfrom slack_sdk import WebClient\nfrom slack_sdk.errors import SlackApiError\nfrom slack_sdk.models.blocks import SectionBlock, DividerBlock, ImageBlock\nfrom litellm import completion\nimport base64\nfrom typing import Dict, List, Tuple, Optional\nimport logging\nimport json\nimport io\nfrom PIL import Image\n\n# Constants\nDEFAULT_ORG_ID = \"1\"\nIMAGE_WIDTH = 1000\nIMAGE_HEIGHT = 500\nTIME_RANGE = \"1h\"\n\n# Update the logging configuration to respect KUBIYA_DEBUG environment variable\nlog_level = logging.DEBUG if os.environ.get('KUBIYA_DEBUG') else logging.WARNING\nlogging.basicConfig(\n    level=log_level,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\ndef generate_grafana_api_url(grafana_dashboard_url: str) -> Tuple[str, str]:\n    parsed_url = urlparse(grafana_dashboard_url)\n    path_parts = parsed_url.path.strip(\"/\").split(\"/\")\n\n    if len(path_parts) >= 3 and path_parts[0] == \"d\":\n        dashboard_uid = path_parts[1]\n    else:\n        raise ValueError(\"URL path does not have the expected format /d/{uid}/{slug}\")\n\n    query_params = parse_qs(parsed_url.query)\n    org_id = query_params.get(\"orgId\", [DEFAULT_ORG_ID])[0]\n\n    api_url = f\"{parsed_url.scheme}://{parsed_url.netloc}/api/dashboards/uid/{dashboard_uid}\"\n    return api_url, org_id\n\ndef get_dashboard_panels(api_url, api_key):\n    headers = {\"Authorization\": f\"Bearer {api_key}\"}\n    try:\n        response = requests.get(api_url, headers=headers)\n        response.raise_for_status()  # Raises an HTTPError for bad responses\n        dashboard_data = response.json()\n        panels = dashboard_data.get('dashboard', {}).get('panels', [])\n        if not panels:\n            raise ValueError(\"No panels found in dashboard\")\n        return [(panel.get('title'), panel.get('id')) for panel in panels if 'title' in panel and 'id' in panel]\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Failed to fetch dashboard data: {str(e)}\")\n        raise\n\ndef generate_grafana_render_url(grafana_dashboard_url, panel_id):\n    parsed_url = urlparse(grafana_dashboard_url)\n    path_parts = parsed_url.path.strip(\"/\").split(\"/\")\n\n    if len(path_parts) >= 3 and path_parts[0] == \"d\":\n        dashboard_uid = path_parts[1]\n        dashboard_slug = path_parts[2]\n    else:\n        raise ValueError(\"URL path does not have the expected format /d/{uid}/{slug}\")\n\n    query_params = parse_qs(parsed_url.query)\n    org_id = query_params.get(\"orgId\", [DEFAULT_ORG_ID])[0]\n\n    render_url = f\"{parsed_url.scheme}://{parsed_url.netloc}/render/d-solo/{dashboard_uid}/{dashboard_slug}?orgId={org_id}&from=now-{TIME_RANGE}&to=now&panelId={panel_id}&width={IMAGE_WIDTH}&height={IMAGE_HEIGHT}\"\n    return render_url, org_id\n\ndef download_panel_image(render_url: str, api_key: str, panel_title: str) -> Optional[bytes]:\n    try:\n        response = requests.get(render_url, headers={\"Authorization\": f\"Bearer {api_key}\"}, stream=True)\n        response.raise_for_status()\n        \n        # Compress the image before returning\n        image = Image.open(io.BytesIO(response.content))\n        compressed_image = io.BytesIO()\n        # Convert to RGB if image is in RGBA mode\n        if image.mode == 'RGBA':\n            image = image.convert('RGB')\n        # Save with reduced quality and size\n        image.save(compressed_image, format='JPEG', quality=70, optimize=True)\n        return compressed_image.getvalue()\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Failed to download panel image {panel_title}: {str(e)}\")\n        return None\n    except Exception as e:\n        logger.error(f\"Failed to process panel image {panel_title}: {str(e)}\")\n        return None\n\ndef send_slack_file_to_thread(token, channel_id, thread_ts, file_path, initial_comment):\n    client = WebClient(token=token)\n    try:\n        response = client.files_upload_v2(\n            channel=channel_id,\n            file=file_path,\n            initial_comment=initial_comment,\n            thread_ts=thread_ts\n        )\n        return response\n    except SlackApiError as e:\n        logger.error(f\"Failed to upload file to Slack: {str(e)}\")\n        raise\n\ndef extract_slack_response_info(response):\n    return {\n        \"ok\": response.get(\"ok\"),\n        \"file_id\": response.get(\"file\", {}).get(\"id\"),\n        \"file_name\": response.get(\"file\", {}).get(\"name\"),\n        \"file_url\": response.get(\"file\", {}).get(\"url_private\"),\n        \"timestamp\": response.get(\"file\", {}).get(\"timestamp\")\n    }\n\ndef analyze_image_with_vision_model(\n    image_content: bytes,\n    panel_title: str,\n    alert_data: Dict\n) -> Optional[Dict[str, str]]:\n    llm_key = os.environ[\"VISION_LLM_KEY\"]\n    llm_base_url = os.environ[\"VISION_LLM_BASE_URL\"]\n\n    base64_image = base64.b64encode(image_content).decode('utf-8')\n\n    prompt = f\"\"\"You are analyzing a Grafana panel titled '{panel_title}' in relation to an alert.\n\nAlert Context:\n{json.dumps(alert_data, indent=2)}\n\nLooking at the Grafana panel image:\n1. Is this panel relevant to understanding or diagnosing the alert condition? Consider metrics, service names, and any other contextual relationships.\n2. If relevant, does the panel data indicate any anomalies or unusual patterns that could be related to the alert?\n3. Based on the panel data, what specific actions should be taken to address the issue?\n\nStart your response with either:\n\"Anomaly detected:\" followed by your analysis if the panel shows an anomaly related to the alert\nOR\n\"No anomaly\" if the panel doesn't show any unusual patterns related to the alert condition.\"\"\"\n\n    try:\n        response = completion(\n            model=\"openai/gpt-4o\",\n            api_key=llm_key,\n            base_url=llm_base_url,\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": [\n                        {\"type\": \"text\", \"text\": prompt},\n                        {\n                            \"type\": \"image_url\",\n                            \"image_url\": {\n                                \"url\": f\"data:image/png;base64,{base64_image}\"\n                            },\n                        },\n                    ],\n                }\n            ],\n        )\n        analysis = response.choices[0].message.content\n        if analysis.lower().startswith('anomaly detected'):\n            return {\n                \"analysis\": analysis,\n                \"panel_title\": panel_title\n            }\n        return None\n    except Exception as e:\n        logger.error(f\"Error analyzing image: {str(e)}\")\n        return None\n\ndef find_related_panels(panels: List[Tuple[str, int]], alert_info: Dict, grafana_dashboard_url: str, grafana_api_key: str) -> List[Dict]:\n    related_panels = []\n    for panel_title, panel_id in panels:\n        logger.info(f\"Analyzing panel: {panel_title}\")\n        render_url, org_id = generate_grafana_render_url(grafana_dashboard_url, panel_id)\n        image_content = download_panel_image(render_url, grafana_api_key, panel_title)\n        \n        if image_content:\n            analysis_result = analyze_image_with_vision_model(image_content, panel_title, alert_info)\n            if analysis_result:\n                panel_info = {\n                    \"title\": panel_title,\n                    \"image_content\": image_content,\n                    \"analysis\": analysis_result[\"analysis\"],\n                    \"render_url\": render_url,\n                    \"org_id\": org_id\n                }\n                related_panels.append(panel_info)\n        else:\n            logger.warning(f\"Failed to download image for panel: {panel_title}\")\n\n    return related_panels\n\ndef find_grafana_url(obj) -> Optional[str]:\n    \"\"\"Recursively search through a dictionary/list to find a Grafana dashboard URL\"\"\"\n    if isinstance(obj, str) and '/d/' in obj:\n        parsed = urlparse(obj)\n        if parsed.scheme and parsed.netloc:\n            return obj\n    elif isinstance(obj, dict):\n        for value in obj.values():\n            found_url = find_grafana_url(value)\n            if found_url:\n                return found_url\n    elif isinstance(obj, list):\n        for item in obj:\n            found_url = find_grafana_url(item)\n            if found_url:\n                return found_url\n    return None\n\ndef send_panel_to_slack(\n    panel_info: Dict,\n    slack_token: str,\n    channel_id: str,\n    thread_ts: str,\n    grafana_dashboard_url: str\n) -> Dict:\n    \"\"\"\n    Send a single panel's information and image to Slack\n    Returns the Slack response info\n    \"\"\"\n    client = WebClient(token=slack_token)\n    \n    # First upload the image\n    with tempfile.NamedTemporaryFile(delete=False, suffix='.jpg') as temp_file:\n        temp_file.write(panel_info['image_content'])\n        temp_file_path = temp_file.name\n        \n    try:\n        # Upload the image first\n        file_upload = client.files_upload_v2(\n            channel=channel_id,\n            file=temp_file_path,\n            thread_ts=thread_ts\n        )\n        \n        # Get the image URL from the upload response\n        image_url = file_upload['files'][0]['url_private']\n        \n        # Create blocks with the uploaded image URL\n        blocks = [\n            SectionBlock(text=f\"📊 *Panel Analysis: {panel_info['title']}*\"),\n            DividerBlock(),\n            SectionBlock(text=(\n                f\"🔗 *Quick Links*\\n\"\n                f\"• Dashboard: {grafana_dashboard_url}\\n\"\n                f\"• Panel URL: {panel_info['render_url']}\\n\"\n                f\"• Org ID: {panel_info['org_id']}\"\n            )),\n            DividerBlock(),\n            SectionBlock(text=f\"📝 *Analysis*\\n{panel_info['analysis']}\"),\n            ImageBlock(\n                image_url=image_url,\n                alt_text=panel_info['title']\n            ),\n            DividerBlock(),\n            SectionBlock(text=\"🔍 *End of Analysis*\")\n        ]\n        \n        # Send the message with blocks\n        client.chat_postMessage(\n            channel=channel_id,\n            thread_ts=thread_ts,\n            blocks=blocks\n        )\n        \n        logger.info(f\"Successfully sent panel {panel_info['title']}\")\n        return extract_slack_response_info(file_upload)\n        \n    except SlackApiError as e:\n        logger.error(f\"Failed to send panel {panel_info['title']}: {str(e)}\")\n        raise\n    finally:\n        os.remove(temp_file_path)\n\ndef main():\n    required_env_vars = [\n        \"SLACK_THREAD_TS\",\n        \"SLACK_CHANNEL_ID\",\n        \"SLACK_API_TOKEN\",\n        \"GRAFANA_API_KEY\",\n        \"VISION_LLM_KEY\",\n        \"VISION_LLM_BASE_URL\"\n    ]\n    \n    missing_vars = [var for var in required_env_vars if not os.environ.get(var)]\n    if missing_vars:\n        raise ValueError(f\"Missing required environment variables: {', '.join(missing_vars)}\")\n    \n    parser = argparse.ArgumentParser(description=\"Process Grafana dashboard and alert data.\")\n    parser.add_argument(\"--alert_payload\", required=True, help=\"JSON string containing the alert payload\")\n    args = parser.parse_args()\n\n    try:\n        alert_data = json.loads(args.alert_payload)\n        grafana_dashboard_url = find_grafana_url(alert_data)\n        if not grafana_dashboard_url:\n            raise ValueError(\"Could not find Grafana dashboard URL in alert payload\")\n        \n    except json.JSONDecodeError:\n        raise ValueError(\"Invalid JSON payload\")\n    except Exception as e:\n        raise ValueError(f\"Error processing alert payload: {str(e)}\")\n\n    thread_ts = os.environ.get(\"SLACK_THREAD_TS\")\n    channel_id = os.environ.get(\"SLACK_CHANNEL_ID\")\n    slack_token = os.environ.get(\"SLACK_API_TOKEN\")\n    grafana_api_key = os.environ.get(\"GRAFANA_API_KEY\")\n\n    api_url, org_id = generate_grafana_api_url(grafana_dashboard_url)\n    all_panels = get_dashboard_panels(api_url, grafana_api_key)\n\n    # Pass the entire alert_data to find_related_panels for context\n    related_panels = find_related_panels(all_panels, alert_data, grafana_dashboard_url, grafana_api_key)\n\n    if not related_panels:\n        logger.info(\"No relevant panels found\")\n        return\n\n    # Send initial summary message with enhanced formatting\n    summary_message = (\n        f\"🔍 *Automated Dashboard Analysis*\\n\"\n        f\"━━━━━━━━━━━━━━━━━━━━━━━━\\n\"\n        f\"📊 Found *{len(related_panels)} relevant panels* with anomalies\\n\"\n        f\"🔗 Dashboard: {grafana_dashboard_url}\\n\\n\"\n        f\"💡 *Detailed analysis for each panel will follow below*\"\n    )\n    \n    client = WebClient(token=slack_token)\n    try:\n        client.chat_postMessage(\n            channel=channel_id,\n            thread_ts=thread_ts,\n            text=summary_message\n        )\n    except SlackApiError as e:\n        logger.error(f\"Failed to send summary message: {str(e)}\")\n\n    # Enhanced panel message formatting\n    for panel_info in related_panels:\n        try:\n            send_panel_to_slack(\n                panel_info=panel_info,\n                slack_token=slack_token,\n                channel_id=channel_id,\n                thread_ts=thread_ts,\n                grafana_dashboard_url=grafana_dashboard_url\n            )\n        except Exception as e:\n            logger.error(f\"Failed to send panel {panel_info['title']}: {str(e)}\")\n\nif __name__ == \"__main__\":\n    main()\n"
        }
      ],
      "with_services": [],
      "with_git_repo": null,
      "with_volumes": [],
      "entrypoint": [],
      "icon_url": null,
      "image": "python:3.12",
      "long_running": false,
      "on_start": null,
      "on_complete": null,
      "mermaid": "graph TD\n    %% Styles\n    classDef triggerClass fill:#3498db,color:#fff,stroke:#2980b9,stroke-width:2px,font-weight:bold\n    classDef paramClass fill:#2ecc71,color:#fff,stroke:#27ae60,stroke-width:2px\n    classDef execClass fill:#e74c3c,color:#fff,stroke:#c0392b,stroke-width:2px,font-weight:bold\n    classDef envClass fill:#f39c12,color:#fff,stroke:#f1c40f,stroke-width:2px\n\n    %% Main Components\n    Trigger(\"Trigger\"):::triggerClass\n    Params(\"Parameters\"):::paramClass\n    Exec(\"analyze_grafana_panel\"):::execClass\n    Env(\"Environment\"):::envClass\n\n    %% Flow\n    Trigger --> Params --> Exec\n    Env --> Exec\n\n    %% Trigger Options\n    User(\"User\")\n    API(\"API\")\n    Webhook(\"Webhook\")\n    Cron(\"Scheduled\")\n    User --> Trigger\n    API --> Trigger\n    Webhook --> Trigger\n    Cron --> Trigger\n\n    %% Parameters\n    subgraph Parameters[\"Parameters\"]\n        direction TB\n        Param0(\"alert_payload (Required)<br/>JSON string containing the alert payload\"):::paramClass\n    end\n    Parameters --- Params\n\n    %% Execution\n    subgraph Execution[\"Execution\"]\n        direction TB\n        Code(\"Script: <br/>pip install slack_sdk > /dev/null 2>&1<br/>pip instal...\")\n        Type(\"Type: Docker\")\n        Image(\"Docker Image: python:3.12\")\n    end\n    Execution --- Exec\n\n    %% Environment\n    subgraph Environment[\"Environment\"]\n        direction TB\n        EnvVars(\"Environment Variables:<br/>SLACK_THREAD_TS<br/>SLACK_CHANNEL_ID<br/>VISION_LLM_BASE_URL\"):::envClass\n        Secrets(\"Secrets:<br/>SLACK_API_TOKEN<br/>GRAFANA_API_KEY<br/>VISION_LLM_KEY\"):::envClass\n    end\n    Environment --- Env\n\n    %% Context Note\n    ContextNote(\"Parameter values can be<br/>fetched from context<br/>based on the trigger\")\n    ContextNote -.-> Params",
      "workflow": false,
      "metadata": {}
    }
  ],
  "errors": [],
  "python_bundle_version": "3.11.9"
}